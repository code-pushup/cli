import {
  copyFile,
  cp,
  mkdir,
  readFile,
  rename,
  writeFile,
} from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { type SimpleGit, simpleGit } from 'simple-git';
import type { MockInstance } from 'vitest';
import type { CoreConfig } from '@code-pushup/models';
import {
  cleanTestFolder,
  initGitRepo,
  simulateGitFetch,
  teardownTestFolder,
} from '@code-pushup/test-utils';
import * as utils from '@code-pushup/utils';
import type {
  Comment,
  GitRefs,
  Logger,
  Options,
  ProviderAPIClient,
  RunResult,
} from './models.js';
import type { MonorepoTool } from './monorepo/index.js';
import { runInCI } from './run.js';

describe('runInCI', () => {
  const fixturesDir = path.join(
    fileURLToPath(path.dirname(import.meta.url)),
    '..',
    '..',
    'mocks',
    'fixtures',
  );
  const reportsDir = path.join(fixturesDir, 'outputs');
  const workDir = path.join(process.cwd(), 'tmp', 'ci', 'run-test');

  const fixturePaths = {
    reports: {
      before: {
        json: path.join(reportsDir, 'report-before.json'),
        md: path.join(reportsDir, 'report-before.md'),
      },
      after: {
        json: path.join(reportsDir, 'report-after.json'),
        md: path.join(reportsDir, 'report-after.md'),
      },
    },
    diffs: {
      project: {
        json: path.join(reportsDir, 'diff-project.json'),
        md: path.join(reportsDir, 'diff-project.md'),
      },
      merged: {
        md: path.join(reportsDir, 'diff-merged.md'),
      },
    },
    config: path.join(reportsDir, 'config.json'),
  };

  const logger: Logger = {
    error: vi.fn(),
    warn: vi.fn(),
    info: vi.fn(),
    debug: vi.fn(),
  };

  const options = {
    bin: 'npx code-pushup',
    directory: workDir,
    logger,
  } satisfies Options;

  const mockComment: Comment = {
    id: 42,
    body: '... <!-- generated by @code-pushup/ci -->',
    url: 'https://fake.hosted.git/comments/42',
  };

  let git: SimpleGit;

  let cwdSpy: MockInstance<
    Parameters<typeof process.cwd>,
    ReturnType<typeof process.cwd>
  >;
  let executeProcessSpy: MockInstance<
    [utils.ProcessConfig],
    Promise<utils.ProcessResult>
  >;

  let yarnVersion: string;

  async function simulateCodePushUpExecution({
    command,
    args,
    cwd,
  }: utils.ProcessConfig): Promise<utils.ProcessResult> {
    const nxMatch = command.match(/nx run (\w+):code-pushup/);
    const outputDir = nxMatch
      ? path.join(workDir, `packages/${nxMatch[1]}/.code-pushup`)
      : path.join(cwd as string, '.code-pushup');
    await mkdir(outputDir, { recursive: true });
    let stdout = '';

    switch (args![0]) {
      case 'compare':
        const diffs = fixturePaths.diffs.project;
        await copyFile(diffs.json, path.join(outputDir, 'report-diff.json'));
        await copyFile(diffs.md, path.join(outputDir, 'report-diff.md'));
        break;

      case 'print-config':
        let content = await readFile(fixturePaths.config, 'utf8');
        if (nxMatch) {
          // simulate effect of custom persist.outputDir per Nx project
          const config = JSON.parse(content) as CoreConfig;
          // eslint-disable-next-line functional/immutable-data
          config.persist!.outputDir = outputDir;
          content = JSON.stringify(config, null, 2);
        }
        const outputFile = args
          ?.find(arg => arg.startsWith('--output='))
          ?.split('=')[1];
        if (outputFile) {
          await writeFile(path.join(cwd as string, outputFile), content);
        } else {
          stdout = content;
        }
        break;

      case 'merge-diffs':
        await copyFile(
          fixturePaths.diffs.merged.md,
          path.join(
            nxMatch ? workDir : (cwd as string),
            '.code-pushup/merged-report-diff.md',
          ),
        );
        break;

      default:
        const kind =
          (await git.branch()).current === 'main' ? 'before' : 'after';
        const reports = fixturePaths.reports[kind];
        if (/workspaces|concurrency|parallel/.test(command)) {
          // eslint-disable-next-line functional/no-loop-statements
          for (const project of ['cli', 'core', 'utils']) {
            const projectOutputDir = path.join(
              workDir,
              `packages/${project}/.code-pushup`,
            );
            await mkdir(projectOutputDir, { recursive: true });
            await copyFile(
              reports.json,
              path.join(projectOutputDir, 'report.json'),
            );
            await copyFile(
              reports.json,
              path.join(projectOutputDir, 'report.md'),
            );
          }
        } else {
          await copyFile(reports.json, path.join(outputDir, 'report.json'));
          await copyFile(reports.md, path.join(outputDir, 'report.md'));
        }
        break;
    }

    return { code: 0, stdout, stderr: '' } as utils.ProcessResult;
  }

  beforeEach(async () => {
    const originalExecuteProcess = utils.executeProcess;
    executeProcessSpy = vi
      .spyOn(utils, 'executeProcess')
      .mockImplementation(cfg => {
        if (cfg.command.includes('code-pushup')) {
          return simulateCodePushUpExecution(cfg);
        }
        if (cfg.command === 'yarn' && cfg.args![0] === '-v') {
          return Promise.resolve({
            code: 0,
            stdout: yarnVersion,
            stderr: '',
          } as utils.ProcessResult);
        }
        return originalExecuteProcess(cfg);
      });

    cwdSpy = vi.spyOn(process, 'cwd').mockReturnValue(workDir);

    await cleanTestFolder(workDir);

    git = await initGitRepo(simpleGit, { baseDir: workDir });
    await simulateGitFetch(git);

    await writeFile(
      path.join(workDir, 'index.js'),
      'console.log("Hello, world!")',
    );
    await git.add('index.js');
    await git.commit('Initial commit');
  });

  afterAll(async () => {
    cwdSpy.mockRestore();
    executeProcessSpy.mockRestore();

    await teardownTestFolder(workDir);
  });

  describe('standalone mode', () => {
    const outputDir = path.join(workDir, '.code-pushup');

    describe('push event', () => {
      beforeEach(async () => {
        await git.checkout('main');
      });

      it('should collect report', async () => {
        await expect(
          runInCI(
            { head: { ref: 'main', sha: await git.revparse('main') } },
            {} as ProviderAPIClient,
            options,
            git,
          ),
        ).resolves.toEqual({
          mode: 'standalone',
          files: {
            report: {
              json: path.join(outputDir, 'report.json'),
              md: path.join(outputDir, 'report.md'),
            },
          },
        } satisfies RunResult);

        expect(utils.executeProcess).toHaveBeenCalledTimes(2);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(1, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(2, {
          command: options.bin,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: workDir,
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });
    });

    describe('pull request event', () => {
      let refs: GitRefs;
      let diffMdString: string;

      beforeEach(async () => {
        await git.checkoutLocalBranch('feature-1');

        await rename(
          path.join(workDir, 'index.js'),
          path.join(workDir, 'index.ts'),
        );

        await git.add('index.ts');
        await git.commit('Convert JS file to TS');

        refs = {
          head: { ref: 'feature-1', sha: await git.revparse('feature-1') },
          base: { ref: 'main', sha: await git.revparse('main') },
        };

        diffMdString = await readFile(fixturePaths.diffs.project.md, 'utf8');
      });

      it('should collect both reports when uncached, compare and create new comment', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn().mockResolvedValue(mockComment),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
        };

        await expect(runInCI(refs, api, options, git)).resolves.toEqual({
          mode: 'standalone',
          commentId: mockComment.id,
          newIssues: [],
          files: {
            report: {
              json: path.join(outputDir, 'report.json'),
              md: path.join(outputDir, 'report.md'),
            },
            diff: {
              json: path.join(outputDir, 'report-diff.json'),
              md: path.join(outputDir, 'report-diff.md'),
            },
          },
        } satisfies RunResult);

        expect(api.listComments).toHaveBeenCalledWith();
        expect(api.createComment).toHaveBeenCalledWith(
          expect.stringContaining(diffMdString),
        );
        expect(api.updateComment).not.toHaveBeenCalled();

        expect(utils.executeProcess).toHaveBeenCalledTimes(5);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(1, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(2, {
          command: options.bin,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(3, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(4, {
          command: options.bin,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(5, {
          command: options.bin,
          args: [
            'compare',
            `--before=${path.join(outputDir, 'prev-report.json')}`,
            `--after=${path.join(outputDir, 'curr-report.json')}`,
            '--persist.format=json',
            '--persist.format=md',
          ],
          cwd: workDir,
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });

      it('should collect new report and use cached old report, compare and update existing comment', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn(),
          updateComment: vi.fn().mockResolvedValue(mockComment),
          listComments: vi.fn().mockResolvedValue([mockComment]),
          downloadReportArtifact: vi.fn().mockImplementation(async () => {
            const downloadPath = path.join(workDir, 'downloaded-report.json');
            await copyFile(fixturePaths.reports.before.json, downloadPath);
            return downloadPath;
          }),
        };

        await expect(runInCI(refs, api, options, git)).resolves.toEqual({
          mode: 'standalone',
          commentId: mockComment.id,
          newIssues: [],
          files: {
            report: {
              json: path.join(outputDir, 'report.json'),
              md: path.join(outputDir, 'report.md'),
            },
            diff: {
              json: path.join(outputDir, 'report-diff.json'),
              md: path.join(outputDir, 'report-diff.md'),
            },
          },
        } satisfies RunResult);

        expect(api.listComments).toHaveBeenCalledWith();
        expect(api.updateComment).toHaveBeenCalledWith(
          mockComment.id,
          expect.stringContaining(diffMdString),
        );
        expect(api.createComment).not.toHaveBeenCalled();
        expect(api.downloadReportArtifact).toHaveBeenCalledWith(undefined);

        expect(utils.executeProcess).toHaveBeenCalledTimes(3);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(1, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(2, {
          command: options.bin,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(3, {
          command: options.bin,
          args: [
            'compare',
            `--before=${path.join(outputDir, 'prev-report.json')}`,
            `--after=${path.join(outputDir, 'curr-report.json')}`,
            '--persist.format=json',
            '--persist.format=md',
          ],
          cwd: workDir,
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });

      it('should skip comment if disabled', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn(),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
        };

        await expect(
          runInCI(refs, api, { ...options, skipComment: true }, git),
        ).resolves.toEqual({
          mode: 'standalone',
          commentId: undefined,
          newIssues: [],
          files: {
            report: {
              json: path.join(outputDir, 'report.json'),
              md: path.join(outputDir, 'report.md'),
            },
            diff: {
              json: path.join(outputDir, 'report-diff.json'),
              md: path.join(outputDir, 'report-diff.md'),
            },
          },
        } satisfies RunResult);

        expect(api.listComments).not.toHaveBeenCalled();
        expect(api.createComment).not.toHaveBeenCalled();
        expect(api.updateComment).not.toHaveBeenCalled();

        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: expect.arrayContaining(['compare']),
          cwd: workDir,
        } satisfies utils.ProcessConfig);
      });
    });
  });

  describe.each<{
    name: string;
    tool: MonorepoTool;
    run: string;
    runMany: string;
    setup?: () => void;
  }>([
    {
      name: 'Nx',
      tool: 'nx',
      run: expect.stringMatching(
        /^npx nx run (cli|core|utils):code-pushup --skip-nx-cache --$/,
      ),
      runMany:
        'npx nx run-many --targets=code-pushup --parallel=false --projects=cli,core,utils --',
    },
    {
      name: 'Turborepo',
      tool: 'turbo',
      run: 'npx turbo run code-pushup --no-cache --force --',
      runMany: 'npx turbo run code-pushup --concurrency=1 --',
    },
    {
      name: 'pnpm workspace',
      tool: 'pnpm',
      run: 'pnpm run code-pushup',
      runMany: 'pnpm --recursive --workspace-concurrency=1 code-pushup',
    },
    {
      name: 'Yarn workspaces (modern)',
      tool: 'yarn',
      run: 'yarn run code-pushup',
      runMany: 'yarn workspaces foreach --all code-pushup',
      setup: () => {
        yarnVersion = '2.0.0';
      },
    },
    {
      name: 'Yarn workspaces (classic)',
      tool: 'yarn',
      run: 'yarn run code-pushup',
      runMany: 'yarn workspaces run code-pushup',
      setup: () => {
        yarnVersion = '1.0.0';
      },
    },
    {
      name: 'npm workspaces',
      tool: 'npm',
      run: 'npm run code-pushup --',
      runMany: 'npm run code-pushup --workspaces --if-present --',
    },
  ])('monorepo mode - $name', ({ tool, run, runMany, setup }) => {
    beforeEach(async () => {
      const monorepoDir = path.join(fixturesDir, 'monorepos', tool);
      await cp(monorepoDir, workDir, { recursive: true });
      await git.add('.');
      await git.commit(`Create packages in ${tool} monorepo`);
      setup?.();
    });

    describe('push event', () => {
      beforeEach(async () => {
        await git.checkout('main');
      });

      it('should collect reports for all projects', async () => {
        await expect(
          runInCI(
            { head: { ref: 'main', sha: await git.revparse('main') } },
            {} as ProviderAPIClient,
            { ...options, monorepo: tool },
            git,
          ),
        ).resolves.toEqual({
          mode: 'monorepo',
          projects: [
            {
              name: 'cli',
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'packages/cli/.code-pushup/report.json',
                  ),
                  md: path.join(workDir, 'packages/cli/.code-pushup/report.md'),
                },
              },
            },
            {
              name: 'core',
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'packages/core/.code-pushup/report.json',
                  ),
                  md: path.join(
                    workDir,
                    'packages/core/.code-pushup/report.md',
                  ),
                },
              },
            },
            {
              name: 'utils',
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'packages/utils/.code-pushup/report.json',
                  ),
                  md: path.join(
                    workDir,
                    'packages/utils/.code-pushup/report.md',
                  ),
                },
              },
            },
          ],
        } satisfies RunResult);

        expect(
          executeProcessSpy.mock.calls.filter(([cfg]) =>
            cfg.command.includes('code-pushup'),
          ),
        ).toHaveLength(4); // 1 autorun for all projects, 3 print-configs for each project
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: run,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: runMany,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });
    });

    describe('pull request event', () => {
      let refs: GitRefs;
      let diffMdString: string;

      beforeEach(async () => {
        await git.checkoutLocalBranch('feature-1');

        await writeFile(path.join(workDir, 'README.md'), '# Hello, world\n');
        await git.add('README.md');
        await git.commit('Create README');

        refs = {
          head: { ref: 'feature-1', sha: await git.revparse('feature-1') },
          base: { ref: 'main', sha: await git.revparse('main') },
        };

        diffMdString = await readFile(fixturePaths.diffs.merged.md, 'utf8');
      });

      it('should collect and compare reports for all projects and comment merged diff', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn().mockResolvedValue(mockComment),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
          downloadReportArtifact: vi.fn().mockImplementation(async project => {
            if (project === 'utils') {
              // simulates a project which has no cached report
              return null;
            }
            const downloadPath = path.join(
              workDir,
              'tmp',
              project,
              'report.json',
            );
            await mkdir(path.dirname(downloadPath), { recursive: true });
            await copyFile(fixturePaths.reports.before.json, downloadPath);
            return downloadPath;
          }),
        };

        await expect(
          runInCI(refs, api, { ...options, monorepo: tool }, git),
        ).resolves.toEqual({
          mode: 'monorepo',
          commentId: mockComment.id,
          diffPath: path.join(workDir, '.code-pushup/merged-report-diff.md'),
          projects: [
            {
              name: 'cli',
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'packages/cli/.code-pushup/report.json',
                  ),
                  md: path.join(workDir, 'packages/cli/.code-pushup/report.md'),
                },
                diff: {
                  json: path.join(
                    workDir,
                    'packages/cli/.code-pushup/report-diff.json',
                  ),
                  md: path.join(
                    workDir,
                    'packages/cli/.code-pushup/report-diff.md',
                  ),
                },
              },
              newIssues: [],
            },
            {
              name: 'core',
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'packages/core/.code-pushup/report.json',
                  ),
                  md: path.join(
                    workDir,
                    'packages/core/.code-pushup/report.md',
                  ),
                },
                diff: {
                  json: path.join(
                    workDir,
                    'packages/core/.code-pushup/report-diff.json',
                  ),
                  md: path.join(
                    workDir,
                    'packages/core/.code-pushup/report-diff.md',
                  ),
                },
              },
              newIssues: [],
            },
            {
              name: 'utils',
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'packages/utils/.code-pushup/report.json',
                  ),
                  md: path.join(
                    workDir,
                    'packages/utils/.code-pushup/report.md',
                  ),
                },
                diff: {
                  json: path.join(
                    workDir,
                    'packages/utils/.code-pushup/report-diff.json',
                  ),
                  md: path.join(
                    workDir,
                    'packages/utils/.code-pushup/report-diff.md',
                  ),
                },
              },
              newIssues: [],
            },
          ],
        } satisfies RunResult);

        await expect(
          readFile(
            path.join(workDir, '.code-pushup/merged-report-diff.md'),
            'utf8',
          ),
        ).resolves.toBe(diffMdString);

        expect(api.listComments).toHaveBeenCalledWith();
        expect(api.createComment).toHaveBeenCalledWith(
          expect.stringContaining(diffMdString),
        );
        expect(api.updateComment).not.toHaveBeenCalled();

        // 1 autorun for all projects
        // 3 print-configs for each project
        // 1 print-config for uncached project
        // 1 autorun for uncached projects
        // 3 compares for each project
        // 1 merge-diffs for all projects
        expect(
          executeProcessSpy.mock.calls.filter(([cfg]) =>
            cfg.command.includes('code-pushup'),
          ),
        ).toHaveLength(10);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: run,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: runMany,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: run,
          args: [
            'compare',
            expect.stringMatching(/^--before=.*prev-report.json$/),
            expect.stringMatching(/^--after=.*curr-report.json$/),
            expect.stringMatching(/^--label=\w+$/),
            '--persist.format=json',
            '--persist.format=md',
          ],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: run,
          args: [
            'merge-diffs',
            `--files=${path.join(workDir, 'packages/cli/.code-pushup/report-diff.json')}`,
            `--files=${path.join(workDir, 'packages/core/.code-pushup/report-diff.json')}`,
            `--files=${path.join(workDir, 'packages/utils/.code-pushup/report-diff.json')}`,
            expect.stringMatching(/^--persist.outputDir=.*\.code-pushup$/),
            '--persist.filename=merged-report',
          ],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });

      it('should skip comment if disabled', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn(),
          updateComment: vi.fn(),
          listComments: vi.fn(),
        };

        await expect(
          runInCI(
            refs,
            api,
            { ...options, monorepo: tool, skipComment: true },
            git,
          ),
        ).resolves.toEqual({
          mode: 'monorepo',
          commentId: undefined,
          diffPath: path.join(workDir, '.code-pushup/merged-report-diff.md'),
          projects: [
            expect.objectContaining({ name: 'cli' }),
            expect.objectContaining({ name: 'core' }),
            expect.objectContaining({ name: 'utils' }),
          ],
        } satisfies RunResult);

        await expect(
          readFile(
            path.join(workDir, '.code-pushup/merged-report-diff.md'),
            'utf8',
          ),
        ).resolves.toBe(diffMdString);

        expect(api.listComments).not.toHaveBeenCalled();
        expect(api.createComment).not.toHaveBeenCalled();
        expect(api.updateComment).not.toHaveBeenCalled();

        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: runMany,
          args: expect.any(Array),
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: run,
          args: expect.arrayContaining(['compare']),
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: run,
          args: expect.arrayContaining(['merge-diffs']),
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
      });
    });
  });

  describe.each<[string, Options]>([
    [
      'projects explicitly configured using folder patterns',
      {
        monorepo: true,
        projects: ['frontend', 'backend/*'],
      },
    ],
    [
      'projects implicitly determined by package.json files',
      {
        monorepo: true,
      },
    ],
  ])('monorepo mode - custom: %s', (_, monorepoOptions) => {
    beforeEach(async () => {
      const monorepoDir = path.join(fixturesDir, 'monorepos', 'custom');
      await cp(monorepoDir, workDir, { recursive: true });
      await git.add('.');
      await git.commit('Create projects in monorepo');
    });

    describe('push event', () => {
      beforeEach(async () => {
        await git.checkout('main');
      });

      it('should collect reports for all projects', async () => {
        await expect(
          runInCI(
            { head: { ref: 'main', sha: await git.revparse('main') } },
            {} as ProviderAPIClient,
            { ...options, ...monorepoOptions },
            git,
          ),
        ).resolves.toEqual({
          mode: 'monorepo',
          projects: [
            {
              name: expect.stringContaining('api'),
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'backend/api/.code-pushup/report.json',
                  ),
                  md: path.join(workDir, 'backend/api/.code-pushup/report.md'),
                },
              },
            },
            {
              name: expect.stringContaining('auth'),
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'backend/auth/.code-pushup/report.json',
                  ),
                  md: path.join(workDir, 'backend/auth/.code-pushup/report.md'),
                },
              },
            },
            {
              name: 'frontend',
              files: {
                report: {
                  json: path.join(workDir, 'frontend/.code-pushup/report.json'),
                  md: path.join(workDir, 'frontend/.code-pushup/report.md'),
                },
              },
            },
          ],
        } satisfies RunResult);

        expect(
          executeProcessSpy.mock.calls.filter(([cfg]) =>
            cfg.command.includes('code-pushup'),
          ),
        ).toHaveLength(6); // 3 autoruns and 3 print-configs for each project
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });
    });

    describe('pull request event', () => {
      let refs: GitRefs;
      let diffMdString: string;

      beforeEach(async () => {
        await git.checkoutLocalBranch('feature-1');

        await writeFile(path.join(workDir, 'README.md'), '# Hello, world\n');
        await git.add('README.md');
        await git.commit('Create README');

        refs = {
          head: { ref: 'feature-1', sha: await git.revparse('feature-1') },
          base: { ref: 'main', sha: await git.revparse('main') },
        };

        diffMdString = await readFile(fixturePaths.diffs.merged.md, 'utf8');
      });

      it('should collect and compare reports for all projects and comment merged diff', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn().mockResolvedValue(mockComment),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
          downloadReportArtifact: vi.fn().mockImplementation(async project => {
            const downloadPath = path.join(
              workDir,
              'tmp',
              project,
              'report.json',
            );
            await mkdir(path.dirname(downloadPath), { recursive: true });
            await copyFile(fixturePaths.reports.before.json, downloadPath);
            return downloadPath;
          }),
        };

        await expect(
          runInCI(refs, api, { ...options, ...monorepoOptions }, git),
        ).resolves.toEqual({
          mode: 'monorepo',
          commentId: mockComment.id,
          diffPath: path.join(workDir, '.code-pushup/merged-report-diff.md'),
          projects: [
            {
              name: expect.stringContaining('api'),
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'backend/api/.code-pushup/report.json',
                  ),
                  md: path.join(workDir, 'backend/api/.code-pushup/report.md'),
                },
                diff: {
                  json: path.join(
                    workDir,
                    'backend/api/.code-pushup/report-diff.json',
                  ),
                  md: path.join(
                    workDir,
                    'backend/api/.code-pushup/report-diff.md',
                  ),
                },
              },
              newIssues: [],
            },
            {
              name: expect.stringContaining('auth'),
              files: {
                report: {
                  json: path.join(
                    workDir,
                    'backend/auth/.code-pushup/report.json',
                  ),
                  md: path.join(workDir, 'backend/auth/.code-pushup/report.md'),
                },
                diff: {
                  json: path.join(
                    workDir,
                    'backend/auth/.code-pushup/report-diff.json',
                  ),
                  md: path.join(
                    workDir,
                    'backend/auth/.code-pushup/report-diff.md',
                  ),
                },
              },
              newIssues: [],
            },
            {
              name: 'frontend',
              files: {
                report: {
                  json: path.join(workDir, 'frontend/.code-pushup/report.json'),
                  md: path.join(workDir, 'frontend/.code-pushup/report.md'),
                },
                diff: {
                  json: path.join(
                    workDir,
                    'frontend/.code-pushup/report-diff.json',
                  ),
                  md: path.join(
                    workDir,
                    'frontend/.code-pushup/report-diff.md',
                  ),
                },
              },
              newIssues: [],
            },
          ],
        } satisfies RunResult);

        await expect(
          readFile(
            path.join(workDir, '.code-pushup/merged-report-diff.md'),
            'utf8',
          ),
        ).resolves.toBe(diffMdString);

        expect(api.listComments).toHaveBeenCalledWith();
        expect(api.createComment).toHaveBeenCalledWith(
          expect.stringContaining(diffMdString),
        );
        expect(api.updateComment).not.toHaveBeenCalled();

        // 3 autoruns for each project
        // 3 print-configs for each project
        // 3 compares for each project
        // 0 autoruns and print-configs for uncached projects
        // 1 merge-diffs for all projects
        expect(
          executeProcessSpy.mock.calls.filter(([cfg]) =>
            cfg.command.includes('code-pushup'),
          ),
        ).toHaveLength(10);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: ['--persist.format=json', '--persist.format=md'],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: [
            'compare',
            expect.stringMatching(/^--before=.*prev-report.json$/),
            expect.stringMatching(/^--after=.*curr-report.json$/),
            expect.stringMatching(/^--label=\w+$/),
            '--persist.format=json',
            '--persist.format=md',
          ],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: [
            'merge-diffs',
            `--files=${path.join(workDir, 'backend/api/.code-pushup/report-diff.json')}`,
            `--files=${path.join(workDir, 'backend/auth/.code-pushup/report-diff.json')}`,
            `--files=${path.join(workDir, 'frontend/.code-pushup/report-diff.json')}`,
            expect.stringMatching(/^--persist.outputDir=.*\.code-pushup$/),
            '--persist.filename=merged-report',
          ],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });
    });
  });
});
