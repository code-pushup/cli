import {
  copyFile,
  cp,
  mkdir,
  readFile,
  rename,
  writeFile,
} from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { type SimpleGit, simpleGit } from 'simple-git';
import { type MockInstance, expect } from 'vitest';
import {
  type ReportFragment,
  downloadReportFromPortal,
} from '@code-pushup/portal-client';
import {
  type CoreConfig,
  DEFAULT_PERSIST_FILENAME,
  DEFAULT_PERSIST_FORMAT,
  DEFAULT_PERSIST_SKIP_REPORT,
} from '@code-pushup/models';
import {
  NX_IGNORED_FILES_TO_RESTORE,
  cleanTestFolder,
  initGitRepo,
  restoreRenamedFiles,
  simulateGitFetch,
  teardownTestFolder,
} from '@code-pushup/test-utils';
import * as utils from '@code-pushup/utils';
import { logger } from '@code-pushup/utils';
import type {
  Comment,
  GitBranch,
  GitRefs,
  Options,
  ProviderAPIClient,
  RunResult,
} from './models.js';
import type { MonorepoTool } from './monorepo/index.js';
import { runInCI } from './run.js';

vi.mock('@code-pushup/portal-client', async importOriginal => {
  const mod: typeof import('@code-pushup/portal-client') =
    await importOriginal();
  return {
    ...mod,
    downloadReportFromPortal: vi.fn(simulateDownloadReportFromPortal),
  };
});

const fixturesDir = path.join(
  fileURLToPath(path.dirname(import.meta.url)),
  '..',
  '..',
  'mocks',
  'fixtures',
);
const reportsDir = path.join(fixturesDir, 'outputs');
const workDir = path.join(process.cwd(), 'tmp', 'ci', 'run-test');

const fixturePaths = {
  reports: {
    before: {
      json: path.join(reportsDir, 'report-before.json'),
      md: path.join(reportsDir, 'report-before.md'),
      portal: path.join(reportsDir, 'report-before.portal.json'),
    },
    after: {
      json: path.join(reportsDir, 'report-after.json'),
      md: path.join(reportsDir, 'report-after.md'),
    },
  },
  diffs: {
    project: {
      json: path.join(reportsDir, 'diff-project.json'),
      md: path.join(reportsDir, 'diff-project.md'),
    },
    merged: {
      md: path.join(reportsDir, 'diff-merged.md'),
    },
  },
  config: {
    base: path.join(reportsDir, 'config.json'),
    portal: path.join(reportsDir, 'config.portal.json'),
  },
};

function simulateDownloadReportFromPortal() {
  return utils.readJsonFile<ReportFragment>(fixturePaths.reports.before.portal);
}

describe('runInCI', () => {
  const options = {
    bin: 'npx code-pushup',
    directory: workDir,
  } satisfies Options;

  const mockComment: Comment = {
    id: 42,
    body: '... <!-- generated by @code-pushup/ci -->',
    url: 'https://fake.hosted.git/comments/42',
  };

  let includeUploadConfig: boolean;

  let git: SimpleGit;

  let cwdSpy: MockInstance<
    Parameters<typeof process.cwd>,
    ReturnType<typeof process.cwd>
  >;
  let executeProcessSpy: MockInstance<
    [utils.ProcessConfig],
    Promise<utils.ProcessResult>
  >;

  let yarnVersion: string;

  async function simulateCodePushUpExecution({
    command,
    args,
    cwd,
  }: utils.ProcessConfig): Promise<utils.ProcessResult> {
    const nxMatch = command.match(/nx run (\w+):code-pushup/);
    const outputDir = nxMatch
      ? path.join(workDir, `packages/${nxMatch[1]}/.code-pushup`)
      : path.join(cwd as string, '.code-pushup');
    await mkdir(outputDir, { recursive: true });
    let stdout = '';

    const isBulkCommand = /workspaces|concurrency|parallel/.test(command);
    const projectOutputDirs = ['cli', 'core', 'utils'].map(project =>
      path.join(workDir, `packages/${project}/.code-pushup`),
    );

    switch (args![0]) {
      case 'compare':
        const diffs = fixturePaths.diffs.project;
        if (isBulkCommand) {
          await Promise.all(
            projectOutputDirs.map(async dir => {
              await mkdir(dir, { recursive: true });
              await copyFile(diffs.json, path.join(dir, 'report-diff.json'));
              await copyFile(diffs.md, path.join(dir, 'report-diff.md'));
            }),
          );
        } else {
          await copyFile(diffs.json, path.join(outputDir, 'report-diff.json'));
          await copyFile(diffs.md, path.join(outputDir, 'report-diff.md'));
        }
        break;

      case 'print-config':
        let content = await readFile(
          includeUploadConfig
            ? fixturePaths.config.portal
            : fixturePaths.config.base,
          'utf8',
        );
        if (nxMatch) {
          // simulate effect of custom persist.outputDir per Nx project
          const config = JSON.parse(content) as CoreConfig;
          // eslint-disable-next-line functional/immutable-data
          config.persist!.outputDir = outputDir;
          content = JSON.stringify(config, null, 2);
        }
        const outputFile = args
          ?.find(arg => arg.startsWith('--output='))
          ?.split('=')[1];
        if (outputFile) {
          const outputPath = path.resolve(cwd as string, outputFile);
          await mkdir(path.dirname(outputPath), { recursive: true });
          await writeFile(outputPath, content);
        } else {
          stdout = content;
        }
        break;

      case 'merge-diffs':
        await copyFile(
          fixturePaths.diffs.merged.md,
          path.join(
            nxMatch ? workDir : (cwd as string),
            '.code-pushup/merged-report-diff.md',
          ),
        );
        break;

      default:
        const kind =
          (await git.branch()).current === 'main' ? 'before' : 'after';
        const reports = fixturePaths.reports[kind];
        if (isBulkCommand) {
          await Promise.all(
            projectOutputDirs.map(async dir => {
              await mkdir(dir, { recursive: true });
              await copyFile(reports.json, path.join(dir, 'report.json'));
              await copyFile(reports.md, path.join(dir, 'report.md'));
            }),
          );
        } else {
          await copyFile(reports.json, path.join(outputDir, 'report.json'));
          await copyFile(reports.md, path.join(outputDir, 'report.md'));
        }
        break;
    }

    return { code: 0, stdout, stderr: '' } as utils.ProcessResult;
  }

  const outputDir = path.join(workDir, '.code-pushup', '.ci');

  beforeEach(async () => {
    includeUploadConfig = false;

    const originalExecuteProcess = utils.executeProcess;
    executeProcessSpy = vi
      .spyOn(utils, 'executeProcess')
      .mockImplementation(cfg => {
        if (cfg.command.includes('code-pushup')) {
          return simulateCodePushUpExecution(cfg);
        }
        if (cfg.command === 'yarn' && cfg.args![0] === '-v') {
          return Promise.resolve({
            code: 0,
            stdout: yarnVersion,
            stderr: '',
          } as utils.ProcessResult);
        }
        return originalExecuteProcess(cfg);
      });

    cwdSpy = vi.spyOn(process, 'cwd').mockReturnValue(workDir);

    await cleanTestFolder(workDir);

    git = await initGitRepo(simpleGit, { baseDir: workDir });
    await simulateGitFetch(git);

    await writeFile(
      path.join(workDir, 'index.js'),
      'console.log("Hello, world!")',
    );
    await git.add('index.js');
    await git.commit('Initial commit');
  });

  afterAll(async () => {
    cwdSpy.mockRestore();
    executeProcessSpy.mockRestore();

    await teardownTestFolder(workDir);
  });

  describe('standalone mode', () => {
    describe('push event', () => {
      beforeEach(async () => {
        await git.checkout('main');
      });

      it('should collect report', async () => {
        await expect(
          runInCI(
            { head: { ref: 'main', sha: await git.revparse('main') } },
            {} as ProviderAPIClient,
            options,
            git,
          ),
        ).resolves.toEqual({
          mode: 'standalone',
          files: {
            current: {
              json: path.join(outputDir, '.current/report.json'),
              md: path.join(outputDir, '.current/report.md'),
            },
          },
        } satisfies RunResult);

        expect(utils.executeProcess).toHaveBeenCalledTimes(2);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(1, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(2, {
          command: options.bin,
          args: [],
          cwd: workDir,
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });
    });

    describe('pull request event', () => {
      let refs: { head: GitBranch; base: GitBranch };
      let diffMdString: string;

      beforeEach(async () => {
        await git.checkoutLocalBranch('feature-1');

        await rename(
          path.join(workDir, 'index.js'),
          path.join(workDir, 'index.ts'),
        );

        await git.add('index.ts');
        await git.commit('Convert JS file to TS');

        refs = {
          head: { ref: 'feature-1', sha: await git.revparse('feature-1') },
          base: { ref: 'main', sha: await git.revparse('main') },
        };

        diffMdString = await readFile(fixturePaths.diffs.project.md, 'utf8');
      });

      it('should collect both reports when uncached, compare and create new comment', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn().mockResolvedValue(mockComment),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
        };

        await expect(runInCI(refs, api, options, git)).resolves.toEqual({
          mode: 'standalone',
          commentId: mockComment.id,
          newIssues: [],
          files: {
            current: {
              json: path.join(outputDir, '.current/report.json'),
              md: path.join(outputDir, '.current/report.md'),
            },
            previous: {
              json: path.join(outputDir, '.previous/report.json'),
              md: path.join(outputDir, '.previous/report.md'),
            },
            comparison: {
              json: path.join(outputDir, '.comparison/report-diff.json'),
              md: path.join(outputDir, '.comparison/report-diff.md'),
            },
          },
        } satisfies RunResult);

        expect(api.listComments).toHaveBeenCalledWith();
        expect(api.createComment).toHaveBeenCalledWith(
          expect.stringContaining(diffMdString),
        );
        expect(api.updateComment).not.toHaveBeenCalled();

        expect(utils.executeProcess).toHaveBeenCalledTimes(5);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(1, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(2, {
          command: options.bin,
          args: [],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(3, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(4, {
          command: options.bin,
          args: [],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(5, {
          command: options.bin,
          args: ['compare'],
          cwd: workDir,
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });

      it('should collect new report and use cached old report, compare and update existing comment', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn(),
          updateComment: vi.fn().mockResolvedValue(mockComment),
          listComments: vi.fn().mockResolvedValue([mockComment]),
          downloadReportArtifact: vi.fn().mockImplementation(async () => {
            const downloadPath = path.join(workDir, 'downloaded-report.json');
            await copyFile(fixturePaths.reports.before.json, downloadPath);
            return downloadPath;
          }),
        };

        await expect(runInCI(refs, api, options, git)).resolves.toEqual({
          mode: 'standalone',
          commentId: mockComment.id,
          newIssues: [],
          files: {
            current: {
              json: path.join(outputDir, '.current/report.json'),
              md: path.join(outputDir, '.current/report.md'),
            },
            previous: {
              json: path.join(outputDir, '.previous/report.json'),
            },
            comparison: {
              json: path.join(outputDir, '.comparison/report-diff.json'),
              md: path.join(outputDir, '.comparison/report-diff.md'),
            },
          },
        } satisfies RunResult);

        expect(api.listComments).toHaveBeenCalledWith();
        expect(api.updateComment).toHaveBeenCalledWith(
          mockComment.id,
          expect.stringContaining(diffMdString),
        );
        expect(api.createComment).not.toHaveBeenCalled();
        expect(api.downloadReportArtifact).toHaveBeenCalledWith(undefined);

        expect(utils.executeProcess).toHaveBeenCalledTimes(3);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(1, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(2, {
          command: options.bin,
          args: [],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(3, {
          command: options.bin,
          args: ['compare'],
          cwd: workDir,
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });

      it('should use cached old report from portal when upload is configured', async () => {
        includeUploadConfig = true;

        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn().mockResolvedValue(mockComment),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
          downloadReportArtifact: vi.fn(),
        };

        await expect(runInCI(refs, api, options, git)).resolves.toEqual({
          mode: 'standalone',
          commentId: mockComment.id,
          newIssues: [],
          files: {
            current: {
              json: path.join(outputDir, '.current/report.json'),
              md: path.join(outputDir, '.current/report.md'),
            },
            previous: {
              json: path.join(outputDir, '.previous/report.json'),
            },
            comparison: {
              json: path.join(outputDir, '.comparison/report-diff.json'),
              md: path.join(outputDir, '.comparison/report-diff.md'),
            },
          },
        } satisfies RunResult);

        expect(downloadReportFromPortal).toHaveBeenCalledWith<
          Parameters<typeof downloadReportFromPortal>
        >({
          server: 'https://api.code-pushup.dunder-mifflin.org/graphql',
          apiKey: 'cp_abcdef0123456789',
          parameters: {
            organization: 'dunder-mifflin',
            project: 'website',
            commit: refs.base.sha,
            withAuditDetails: true,
          },
        });

        expect(api.downloadReportArtifact).not.toHaveBeenCalled();

        expect(utils.executeProcess).toHaveBeenCalledTimes(3);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(1, {
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(2, {
          command: options.bin,
          args: [],
          cwd: workDir,
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenNthCalledWith(3, {
          command: options.bin,
          args: ['compare'],
          cwd: workDir,
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });

      it('should skip comment if disabled', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn(),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
        };

        await expect(
          runInCI(refs, api, { ...options, skipComment: true }, git),
        ).resolves.toEqual({
          mode: 'standalone',
          commentId: undefined,
          newIssues: [],
          files: {
            current: {
              json: path.join(outputDir, '.current/report.json'),
              md: path.join(outputDir, '.current/report.md'),
            },
            previous: {
              json: path.join(outputDir, '.previous/report.json'),
              md: path.join(outputDir, '.previous/report.md'),
            },
            comparison: {
              json: path.join(outputDir, '.comparison/report-diff.json'),
              md: path.join(outputDir, '.comparison/report-diff.md'),
            },
          },
        } satisfies RunResult);

        expect(api.listComments).not.toHaveBeenCalled();
        expect(api.createComment).not.toHaveBeenCalled();
        expect(api.updateComment).not.toHaveBeenCalled();

        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: expect.arrayContaining(['compare']),
          cwd: workDir,
        } satisfies utils.ProcessConfig);
      });
    });
  });

  describe.each<{
    name: string;
    tool: MonorepoTool;
    run: string;
    runMany: string;
    persistOutputDir: string;
    setup?: () => void;
  }>([
    {
      name: 'Nx',
      tool: 'nx',
      run: expect.stringMatching(
        /^npx nx run (cli|core|utils):code-pushup --$/,
      ),
      runMany:
        'npx nx run-many --targets=code-pushup --parallel=false --projects=cli,core,utils --',
      persistOutputDir: 'packages/{projectName}/.code-pushup',
    },
    {
      name: 'Turborepo',
      tool: 'turbo',
      run: 'npx turbo run code-pushup --',
      runMany: 'npx turbo run code-pushup --concurrency=1 --',
      persistOutputDir: '.code-pushup',
    },
    {
      name: 'pnpm workspace',
      tool: 'pnpm',
      run: 'pnpm run code-pushup',
      runMany: 'pnpm --recursive --workspace-concurrency=1 code-pushup',
      persistOutputDir: '.code-pushup',
    },
    {
      name: 'Yarn workspaces (modern)',
      tool: 'yarn',
      run: 'yarn run code-pushup',
      runMany: 'yarn workspaces foreach --all code-pushup',
      persistOutputDir: '.code-pushup',
      setup: () => {
        yarnVersion = '2.0.0';
      },
    },
    {
      name: 'Yarn workspaces (classic)',
      tool: 'yarn',
      run: 'yarn run code-pushup',
      runMany: 'yarn workspaces run code-pushup',
      persistOutputDir: '.code-pushup',
      setup: () => {
        yarnVersion = '1.0.0';
      },
    },
    {
      name: 'npm workspaces',
      tool: 'npm',
      run: 'npm run code-pushup --',
      runMany: 'npm run code-pushup --workspaces --if-present --',
      persistOutputDir: '.code-pushup',
    },
  ])(
    'monorepo mode - $name',
    ({ tool, run, runMany, persistOutputDir, setup }) => {
      beforeEach(async () => {
        const monorepoDir = path.join(fixturesDir, 'monorepos', tool);
        await cp(monorepoDir, workDir, { recursive: true });
        await restoreRenamedFiles(workDir, NX_IGNORED_FILES_TO_RESTORE);
        await git.add('.');
        await git.commit(`Create packages in ${tool} monorepo`);
        setup?.();
      });

      describe('push event', () => {
        beforeEach(async () => {
          await git.checkout('main');
        });

        it('should collect reports for all projects', async () => {
          await expect(
            runInCI(
              { head: { ref: 'main', sha: await git.revparse('main') } },
              {} as ProviderAPIClient,
              { ...options, monorepo: tool },
              git,
            ),
          ).resolves.toEqual({
            mode: 'monorepo',
            projects: [
              {
                name: 'cli',
                files: {
                  current: {
                    json: path.join(outputDir, 'cli/.current/report.json'),
                    md: path.join(outputDir, 'cli/.current/report.md'),
                  },
                },
              },
              {
                name: 'core',
                files: {
                  current: {
                    json: path.join(outputDir, 'core/.current/report.json'),
                    md: path.join(outputDir, 'core/.current/report.md'),
                  },
                },
              },
              {
                name: 'utils',
                files: {
                  current: {
                    json: path.join(outputDir, 'utils/.current/report.json'),
                    md: path.join(outputDir, 'utils/.current/report.md'),
                  },
                },
              },
            ],
          } satisfies RunResult);

          expect(
            executeProcessSpy.mock.calls.filter(([cfg]) =>
              cfg.command.includes('code-pushup'),
            ),
          ).toHaveLength(4); // 1 autorun for all projects, 3 print-configs for each project
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: run,
            args: [
              'print-config',
              expect.stringMatching(/^--output=.*\.json$/),
            ],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: [],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);

          expect(logger.error).not.toHaveBeenCalled();
          expect(logger.warn).not.toHaveBeenCalled();
          expect(logger.info).toHaveBeenCalled();
          expect(logger.debug).toHaveBeenCalled();
        });

        it('should skip print-config if configPatterns provided', async () => {
          await expect(
            runInCI(
              { head: { ref: 'main', sha: await git.revparse('main') } },
              {} as ProviderAPIClient,
              {
                ...options,
                monorepo: tool,
                configPatterns: {
                  persist: {
                    outputDir: persistOutputDir,
                    filename: DEFAULT_PERSIST_FILENAME,
                    format: DEFAULT_PERSIST_FORMAT,
                    skipReports: DEFAULT_PERSIST_SKIP_REPORT,
                  },
                },
              },
              git,
            ),
          ).resolves.toEqual({
            mode: 'monorepo',
            projects: [
              {
                name: 'cli',
                files: {
                  current: {
                    json: path.join(outputDir, 'cli/.current/report.json'),
                    md: path.join(outputDir, 'cli/.current/report.md'),
                  },
                },
              },
              {
                name: 'core',
                files: {
                  current: {
                    json: path.join(outputDir, 'core/.current/report.json'),
                    md: path.join(outputDir, 'core/.current/report.md'),
                  },
                },
              },
              {
                name: 'utils',
                files: {
                  current: {
                    json: path.join(outputDir, 'utils/.current/report.json'),
                    md: path.join(outputDir, 'utils/.current/report.md'),
                  },
                },
              },
            ],
          } satisfies RunResult);

          expect(
            executeProcessSpy.mock.calls.filter(([cfg]) =>
              cfg.command.includes('code-pushup'),
            ),
          ).toHaveLength(1); // 1 autorun for all projects (0 print-configs)
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: [],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);

          expect(logger.error).not.toHaveBeenCalled();
          expect(logger.warn).not.toHaveBeenCalled();
          expect(logger.info).toHaveBeenCalled();
          expect(logger.debug).toHaveBeenCalled();
        });
      });

      describe('pull request event', () => {
        let refs: GitRefs;
        let diffMdString: string;

        beforeEach(async () => {
          await git.checkoutLocalBranch('feature-1');

          await writeFile(path.join(workDir, 'README.md'), '# Hello, world\n');
          await git.add('README.md');
          await git.commit('Create README');

          refs = {
            head: { ref: 'feature-1', sha: await git.revparse('feature-1') },
            base: { ref: 'main', sha: await git.revparse('main') },
          };

          diffMdString = await readFile(fixturePaths.diffs.merged.md, 'utf8');
        });

        it('should collect and compare reports for all projects and comment merged diff', async () => {
          const api: ProviderAPIClient = {
            maxCommentChars: 1_000_000,
            createComment: vi.fn().mockResolvedValue(mockComment),
            updateComment: vi.fn(),
            listComments: vi.fn().mockResolvedValue([]),
            downloadReportArtifact: vi
              .fn()
              .mockImplementation(async project => {
                if (project === 'utils') {
                  // simulates a project which has no cached report
                  return null;
                }
                const downloadPath = path.join(
                  workDir,
                  'tmp',
                  project,
                  'report.json',
                );
                await mkdir(path.dirname(downloadPath), { recursive: true });
                await copyFile(fixturePaths.reports.before.json, downloadPath);
                return downloadPath;
              }),
          };

          await expect(
            runInCI(refs, api, { ...options, monorepo: tool }, git),
          ).resolves.toEqual({
            mode: 'monorepo',
            commentId: mockComment.id,
            files: {
              comparison: {
                md: path.join(outputDir, '.comparison/report-diff.md'),
              },
            },
            projects: [
              {
                name: 'cli',
                files: {
                  current: {
                    json: path.join(outputDir, 'cli/.current/report.json'),
                    md: path.join(outputDir, 'cli/.current/report.md'),
                  },
                  previous: {
                    json: path.join(outputDir, 'cli/.previous/report.json'),
                  },
                  comparison: {
                    json: path.join(
                      outputDir,
                      'cli/.comparison/report-diff.json',
                    ),
                    md: path.join(outputDir, 'cli/.comparison/report-diff.md'),
                  },
                },
                newIssues: [],
              },
              {
                name: 'core',
                files: {
                  current: {
                    json: path.join(outputDir, 'core/.current/report.json'),
                    md: path.join(outputDir, 'core/.current/report.md'),
                  },
                  previous: {
                    json: path.join(outputDir, 'core/.previous/report.json'),
                  },
                  comparison: {
                    json: path.join(
                      outputDir,
                      'core/.comparison/report-diff.json',
                    ),
                    md: path.join(outputDir, 'core/.comparison/report-diff.md'),
                  },
                },
                newIssues: [],
              },
              {
                name: 'utils',
                files: {
                  current: {
                    json: path.join(outputDir, 'utils/.current/report.json'),
                    md: path.join(outputDir, 'utils/.current/report.md'),
                  },
                  previous: {
                    json: path.join(outputDir, 'utils/.previous/report.json'),
                    md: path.join(outputDir, 'utils/.previous/report.md'),
                  },
                  comparison: {
                    json: path.join(
                      outputDir,
                      'utils/.comparison/report-diff.json',
                    ),
                    md: path.join(
                      outputDir,
                      'utils/.comparison/report-diff.md',
                    ),
                  },
                },
                newIssues: [],
              },
            ],
          } satisfies RunResult);

          await expect(
            readFile(
              path.join(outputDir, '.comparison/report-diff.md'),
              'utf8',
            ),
          ).resolves.toBe(diffMdString);

          expect(api.listComments).toHaveBeenCalledWith();
          expect(api.createComment).toHaveBeenCalledWith(
            expect.stringContaining(diffMdString),
          );
          expect(api.updateComment).not.toHaveBeenCalled();

          // 1 autorun for all projects
          // 3 print-configs for each project
          // 1 print-config for uncached project
          // 1 autorun for uncached projects
          // 1 compare for all projects
          // 1 merge-diffs for all projects
          expect(
            executeProcessSpy.mock.calls.filter(([cfg]) =>
              cfg.command.includes('code-pushup'),
            ),
          ).toHaveLength(8);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: run,
            args: [
              'print-config',
              expect.stringMatching(/^--output=.*\.json$/),
            ],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: [],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: ['compare'],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: run,
            args: [
              'merge-diffs',
              expect.stringMatching(
                /^--files=.*[/\\]cli[/\\]\.comparison[/\\]report-diff\.json$/,
              ),
              expect.stringMatching(
                /^--files=.*[/\\]core[/\\]\.comparison[/\\]report-diff\.json$/,
              ),
              expect.stringMatching(
                /^--files=.*[/\\]utils[/\\]\.comparison[/\\]report-diff\.json$/,
              ),
              expect.stringMatching(/^--persist.outputDir=.*\.code-pushup$/),
              '--persist.filename=merged-report',
            ],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);

          expect(logger.error).not.toHaveBeenCalled();
          expect(logger.warn).not.toHaveBeenCalled();
          expect(logger.info).toHaveBeenCalled();
          expect(logger.debug).toHaveBeenCalled();
        });

        it('should skip print-config for source and target branches if configPatterns provided', async () => {
          const api: ProviderAPIClient = {
            maxCommentChars: 1_000_000,
            createComment: vi.fn().mockResolvedValue(mockComment),
            updateComment: vi.fn(),
            listComments: vi.fn().mockResolvedValue([]),
          };

          await expect(
            runInCI(
              refs,
              api,
              {
                ...options,
                monorepo: tool,
                configPatterns: {
                  persist: {
                    outputDir: persistOutputDir,
                    filename: DEFAULT_PERSIST_FILENAME,
                    format: DEFAULT_PERSIST_FORMAT,
                    skipReports: DEFAULT_PERSIST_SKIP_REPORT,
                  },
                },
              },
              git,
            ),
          ).resolves.toEqual({
            mode: 'monorepo',
            commentId: mockComment.id,
            files: {
              comparison: {
                md: path.join(outputDir, '.comparison/report-diff.md'),
              },
            },
            projects: [
              expect.objectContaining({ name: 'cli' }),
              expect.objectContaining({ name: 'core' }),
              expect.objectContaining({ name: 'utils' }),
            ],
          } satisfies RunResult);

          await expect(
            readFile(
              path.join(outputDir, '.comparison/report-diff.md'),
              'utf8',
            ),
          ).resolves.toBe(diffMdString);

          expect(api.listComments).toHaveBeenCalledWith();
          expect(api.createComment).toHaveBeenCalledWith(
            expect.stringContaining(diffMdString),
          );
          expect(api.updateComment).not.toHaveBeenCalled();

          // 1 autorun for all projects
          // 1 autorun for uncached projects
          // 1 compare for all projects
          // 1 merge-diffs for all projects
          expect(
            executeProcessSpy.mock.calls.filter(([cfg]) =>
              cfg.command.includes('code-pushup'),
            ),
          ).toHaveLength(4);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: [],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: ['compare'],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: run,
            args: [
              'merge-diffs',
              expect.stringMatching(
                /^--files=.*[/\\]cli[/\\]\.comparison[/\\]report-diff\.json$/,
              ),
              expect.stringMatching(
                /^--files=.*[/\\]core[/\\]\.comparison[/\\]report-diff\.json$/,
              ),
              expect.stringMatching(
                /^--files=.*[/\\]utils[/\\]\.comparison[/\\]report-diff\.json$/,
              ),
              expect.stringMatching(/^--persist.outputDir=.*\.code-pushup$/),
              '--persist.filename=merged-report',
            ],
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).not.toHaveBeenCalledWith(
            expect.objectContaining({
              args: expect.arrayContaining(['print-config']),
            }),
          );

          expect(logger.error).not.toHaveBeenCalled();
          expect(logger.warn).not.toHaveBeenCalled();
          expect(logger.info).toHaveBeenCalled();
          expect(logger.debug).toHaveBeenCalled();
        });

        it('should skip comment if disabled', async () => {
          const api: ProviderAPIClient = {
            maxCommentChars: 1_000_000,
            createComment: vi.fn(),
            updateComment: vi.fn(),
            listComments: vi.fn(),
          };

          await expect(
            runInCI(
              refs,
              api,
              { ...options, monorepo: tool, skipComment: true },
              git,
            ),
          ).resolves.toEqual({
            mode: 'monorepo',
            commentId: undefined,
            files: expect.any(Object),
            projects: [
              expect.objectContaining({ name: 'cli' }),
              expect.objectContaining({ name: 'core' }),
              expect.objectContaining({ name: 'utils' }),
            ],
          } satisfies RunResult);

          await expect(
            readFile(
              path.join(outputDir, '.comparison/report-diff.md'),
              'utf8',
            ),
          ).resolves.toBe(diffMdString);

          expect(api.listComments).not.toHaveBeenCalled();
          expect(api.createComment).not.toHaveBeenCalled();
          expect(api.updateComment).not.toHaveBeenCalled();

          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: expect.any(Array),
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: runMany,
            args: expect.arrayContaining(['compare']),
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
          expect(utils.executeProcess).toHaveBeenCalledWith({
            command: run,
            args: expect.arrayContaining(['merge-diffs']),
            cwd: expect.stringContaining(workDir),
          } satisfies utils.ProcessConfig);
        });
      });
    },
  );

  describe.each<[string, Options]>([
    [
      'projects explicitly configured using folder patterns',
      {
        monorepo: true,
        projects: ['frontend', 'backend/*'],
      },
    ],
    [
      'projects implicitly determined by package.json files',
      {
        monorepo: true,
      },
    ],
  ])('monorepo mode - custom: %s', (_, monorepoOptions) => {
    beforeEach(async () => {
      const monorepoDir = path.join(fixturesDir, 'monorepos', 'custom');
      await cp(monorepoDir, workDir, { recursive: true });
      await restoreRenamedFiles(workDir, NX_IGNORED_FILES_TO_RESTORE);
      await git.add('.');
      await git.commit('Create projects in monorepo');
    });

    describe('push event', () => {
      beforeEach(async () => {
        await git.checkout('main');
      });

      it('should collect reports for all projects', async () => {
        await expect(
          runInCI(
            { head: { ref: 'main', sha: await git.revparse('main') } },
            {} as ProviderAPIClient,
            { ...options, ...monorepoOptions },
            git,
          ),
        ).resolves.toEqual({
          mode: 'monorepo',
          projects: [
            {
              name: expect.stringContaining('api'),
              files: {
                current: {
                  json: expect.stringContaining(
                    path.join('api/.current/report.json'),
                  ),
                  md: expect.stringContaining(
                    path.join('api/.current/report.md'),
                  ),
                },
              },
            },
            {
              name: expect.stringContaining('auth'),
              files: {
                current: {
                  json: expect.stringContaining(
                    path.join('auth/.current/report.json'),
                  ),
                  md: expect.stringContaining(
                    path.join('auth/.current/report.md'),
                  ),
                },
              },
            },
            {
              name: 'frontend',
              files: {
                current: {
                  json: path.join(outputDir, 'frontend/.current/report.json'),
                  md: path.join(outputDir, 'frontend/.current/report.md'),
                },
              },
            },
          ],
        } satisfies RunResult);

        expect(
          executeProcessSpy.mock.calls.filter(([cfg]) =>
            cfg.command.includes('code-pushup'),
          ),
        ).toHaveLength(6); // 3 autoruns and 3 print-configs for each project
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: [],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });
    });

    describe('pull request event', () => {
      let refs: GitRefs;
      let diffMdString: string;

      beforeEach(async () => {
        await git.checkoutLocalBranch('feature-1');

        await writeFile(path.join(workDir, 'README.md'), '# Hello, world\n');
        await git.add('README.md');
        await git.commit('Create README');

        refs = {
          head: { ref: 'feature-1', sha: await git.revparse('feature-1') },
          base: { ref: 'main', sha: await git.revparse('main') },
        };

        diffMdString = await readFile(fixturePaths.diffs.merged.md, 'utf8');
      });

      it('should collect and compare reports for all projects and comment merged diff', async () => {
        const api: ProviderAPIClient = {
          maxCommentChars: 1_000_000,
          createComment: vi.fn().mockResolvedValue(mockComment),
          updateComment: vi.fn(),
          listComments: vi.fn().mockResolvedValue([]),
          downloadReportArtifact: vi.fn().mockImplementation(async project => {
            const downloadPath = path.join(
              workDir,
              'tmp',
              project,
              'report.json',
            );
            await mkdir(path.dirname(downloadPath), { recursive: true });
            await copyFile(fixturePaths.reports.before.json, downloadPath);
            return downloadPath;
          }),
        };

        await expect(
          runInCI(refs, api, { ...options, ...monorepoOptions }, git),
        ).resolves.toEqual({
          mode: 'monorepo',
          commentId: mockComment.id,
          files: {
            comparison: {
              md: path.join(outputDir, '.comparison/report-diff.md'),
            },
          },
          projects: [
            {
              name: expect.stringContaining('api'),
              files: {
                current: {
                  json: expect.stringContaining(
                    path.join('api/.current/report.json'),
                  ),
                  md: expect.stringContaining(
                    path.join('api/.current/report.md'),
                  ),
                },
                previous: {
                  json: expect.stringContaining(
                    path.join('api/.previous/report.json'),
                  ),
                },
                comparison: {
                  json: expect.stringContaining(
                    path.join('api/.comparison/report-diff.json'),
                  ),
                  md: expect.stringContaining(
                    path.join('api/.comparison/report-diff.md'),
                  ),
                },
              },
              newIssues: [],
            },
            {
              name: expect.stringContaining('auth'),
              files: {
                current: {
                  json: expect.stringContaining(
                    path.join('auth/.current/report.json'),
                  ),
                  md: expect.stringContaining(
                    path.join('auth/.current/report.md'),
                  ),
                },
                previous: {
                  json: expect.stringContaining(
                    path.join('auth/.previous/report.json'),
                  ),
                },
                comparison: {
                  json: expect.stringContaining(
                    path.join('auth/.comparison/report-diff.json'),
                  ),
                  md: expect.stringContaining(
                    path.join('auth/.comparison/report-diff.md'),
                  ),
                },
              },
              newIssues: [],
            },
            {
              name: 'frontend',
              files: {
                current: {
                  json: path.join(outputDir, 'frontend/.current/report.json'),
                  md: path.join(outputDir, 'frontend/.current/report.md'),
                },
                previous: {
                  json: path.join(outputDir, 'frontend/.previous/report.json'),
                },
                comparison: {
                  json: path.join(
                    outputDir,
                    'frontend/.comparison/report-diff.json',
                  ),
                  md: path.join(
                    outputDir,
                    'frontend/.comparison/report-diff.md',
                  ),
                },
              },
              newIssues: [],
            },
          ],
        } satisfies RunResult);

        await expect(
          readFile(path.join(outputDir, '.comparison/report-diff.md'), 'utf8'),
        ).resolves.toBe(diffMdString);

        expect(api.listComments).toHaveBeenCalledWith();
        expect(api.createComment).toHaveBeenCalledWith(
          expect.stringContaining(diffMdString),
        );
        expect(api.updateComment).not.toHaveBeenCalled();

        // 3 autoruns for each project
        // 3 print-configs for each project
        // 3 compares for each project
        // 0 autoruns and print-configs for uncached projects
        // 1 merge-diffs for all projects
        expect(
          executeProcessSpy.mock.calls.filter(([cfg]) =>
            cfg.command.includes('code-pushup'),
          ),
        ).toHaveLength(10);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: ['print-config', expect.stringMatching(/^--output=.*\.json$/)],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: [],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: ['compare'],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);
        expect(utils.executeProcess).toHaveBeenCalledWith({
          command: options.bin,
          args: [
            'merge-diffs',
            expect.stringMatching(
              /^--files=.*api[/\\]\.comparison[/\\]report-diff\.json$/,
            ),
            expect.stringMatching(
              /^--files=.*auth[/\\]\.comparison[/\\]report-diff\.json$/,
            ),
            expect.stringMatching(
              /^--files=.*frontend[/\\]\.comparison[/\\]report-diff\.json$/,
            ),
            expect.stringMatching(/^--persist.outputDir=.*\.code-pushup$/),
            '--persist.filename=merged-report',
          ],
          cwd: expect.stringContaining(workDir),
        } satisfies utils.ProcessConfig);

        expect(logger.error).not.toHaveBeenCalled();
        expect(logger.warn).not.toHaveBeenCalled();
        expect(logger.info).toHaveBeenCalled();
        expect(logger.debug).toHaveBeenCalled();
      });
    });
  });
});
